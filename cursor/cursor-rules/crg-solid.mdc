---
description: SOLID design principles and architectural patterns for maintainable code
globs:
alwaysApply: true
---
# SOLID Design Principles

## Core Design Philosophy
- Follow SOLID principles in all software development
- Apply principles contextually and pragmatically
- Use patterns to solve recurring problems
- Maintain separation of concerns
- Design for testability

## SOLID Principles
### Single Responsibility Principle
- Each class/module should have only one reason to change
- Functions should do one thing and do it well
- Split large classes/functions into smaller, focused ones
- Example: Separate data access, business logic, and presentation

### Open/Closed Principle
- Software entities should be open for extension but closed for modification
- Use interfaces and abstract classes to enable extension
- Implement strategy pattern for varying behaviors
- Example: Add new functionality via inheritance or composition, not modification

### Liskov Substitution Principle
- Subtypes must be substitutable for their base types
- Derived classes must not change base class behavior
- Override methods should respect parent class contracts
- Example: If code works with Parent class, it should work with Child class

### Interface Segregation Principle
- Clients shouldn't depend on interfaces they don't use
- Create specific interfaces rather than general-purpose ones
- Keep interfaces focused and minimal
- Example: Split large interfaces into smaller, role-specific ones

### Dependency Inversion Principle
- High-level modules should not depend on low-level modules
- Both should depend on abstractions
- Abstractions should not depend on details
- Example: Use dependency injection and inversion of control

## File Structure Principles
- Keep files small and focused (<200 lines)
- Structure code by feature, not by type
- Group related functionality together
- Use consistent naming across the codebase
- Design directories to reflect domain concepts

## Code Quality Metrics
- Minimize cyclomatic complexity
- Reduce coupling between components
- Maximize cohesion within components
- Prefer composition over inheritance
- Ensure clear separation of concerns

## Practical Application
- Use design patterns appropriately
- Build systems from composable parts
- Favor explicit over implicit
- Design for change and extension
- Consider future maintainers
