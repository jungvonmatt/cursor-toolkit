---
description:
globs:
alwaysApply: true
---

# Interaction Modes & Command Triggers

## üéØ Core Mode Principles
- Interaction modes provide clear boundaries and expectations
- Modes control the scope and type of AI assistance
- Commands trigger specific behavior patterns
- Context-sensitivity ensures appropriate mode selection
- Explicit mode transitions provide predictability

## üîÑ Mode System

### ‚ö†Ô∏è CRITICAL: Mode Activation
- Modes are activated through explicit command triggers
- Commands begin with `$` followed by the mode name
- Example: `$analyze`, `$plan`, `$implement`
- AI must respect mode boundaries once activated
- Modes remain active until task completion or mode change

### Mode Persistence
- Modes persist across multiple interactions within a session
- AI should remind user of current active mode if unclear
- Reference previous mode if continuing from earlier
- Explicitly note mode transitions for clarity

## üìä Analysis Modes

### `$analyze`
- **Purpose**: Understand and evaluate without implementation
- **Behavior**:
  - Analyze code, architecture, or concepts
  - Provide insights and observations
  - Identify potential issues or improvements
  - Do NOT make any implementations or changes
  - Present alternatives with pros/cons
- **Output Format**:
  - Summary of key findings
  - Detailed analysis by component
  - Technical implications
  - Recommendations (without implementation)

### `$research`
- **Purpose**: Comprehensive research and information gathering
- **Behavior**:
  - Conduct thorough web research
  - Use multiple reliable sources
  - Evaluate approaches and best practices
  - Synthesize findings into actionable insights
- **Research Protocol**:
  1. Brave web search for current practices
  2. Stack Overflow for solutions
  3. MDN for web standards
  4. GitHub for implementations
  5. Package registries for tools
- **Output Format**:
  - Summary of research findings
  - Comparison of approaches
  - Actionable recommendations
  - Source references

### `$review`
- **Purpose**: Evaluate code quality and provide feedback
- **Behavior**:
  - Review code for issues and improvements
  - Check against best practices
  - Identify potential bugs or edge cases
  - Suggest specific improvements
- **Review Framework**:
  - Functionality: Does it work as intended?
  - Readability: Is the code clear and maintainable?
  - Performance: Are there optimization opportunities?
  - Security: Are there potential vulnerabilities?
  - Testing: Is test coverage adequate?
- **Output Format**:
  - Overall assessment
  - File-by-file or component-by-component review
  - Prioritized improvement list
  - Code examples for suggested changes

## üìã Planning Modes

### `$plan`
- **Purpose**: Create detailed implementation plans
- **Behavior**:
  - Break down tasks into implementable steps
  - Define clear deliverables and acceptance criteria
  - Identify potential challenges and solutions
  - Create a structured approach
- **Planning Framework**:
  1. Requirements analysis
  2. Technical approach selection
  3. Component breakdown
  4. Implementation steps
  5. Testing strategy
  6. Rollout considerations
- **Output Format**:
  - Executive summary
  - Detailed step-by-step plan
  - Timeline estimates
  - Risk assessment
  - Success metrics

### `$arch`
- **Purpose**: Architecture and design planning
- **Behavior**:
  - Focus on high-level system design
  - Define component interactions
  - Establish patterns and principles
  - Consider scalability, maintainability, and performance
- **Architecture Considerations**:
  - Component responsibilities
  - Data flow and state management
  - API design and contracts
  - Dependency management
  - Error handling and resilience
- **Output Format**:
  - Architecture overview diagram (described in text)
  - Component specifications
  - Interaction patterns
  - Technical constraints and considerations
  - Implementation recommendations

## üõ†Ô∏è Implementation Modes

### `$implement`
- **Purpose**: Execute focused code changes
- **Behavior**:
  - Write or modify code to implement requirements
  - Follow established patterns and best practices
  - Ensure proper error handling and edge cases
  - Include appropriate tests and documentation
- **Implementation Stages**:
  1. Confirm requirements and approach
  2. Make minimal necessary changes
  3. Add appropriate tests
  4. Document changes
  5. Verify implementation
- **Output Format**:
  - Implementation plan
  - Code changes
  - Test additions
  - Documentation updates

### `$scope [files]`
- **Purpose**: Define implementation boundaries
- **Behavior**:
  - Limit changes to specified files or components
  - Respect the defined scope boundaries
  - Request explicit permission for scope expansion
  - Document any implications beyond scope
- **Usage**:
  - `$scope file1.py file2.py` - Limit to specific files
  - `$scope module/` - Limit to specific directory
  - `$scope *.py` - Limit to specific file type
- **Output Format**:
  - Confirmation of scope
  - Implementation within scope
  - Noted implications beyond scope (if any)

### `$protect [files]`
- **Purpose**: Mark files as protected from changes
- **Behavior**:
  - Never modify protected files
  - Suggest alternative approaches if needed
  - Document implications of protection
  - Request explicit permission if changes are necessary
- **Usage**:
  - `$protect file1.py file2.py` - Protect specific files
  - `$protect module/` - Protect specific directory
  - `$protect *.py` - Protect specific file type
- **Output Format**:
  - Confirmation of protected files
  - Implementation avoiding protected files
  - Alternative approaches if needed

## üîç Debug Modes

### `$debug`
- **Purpose**: Analyze and fix issues
- **Behavior**:
  - Identify root causes of problems
  - Propose targeted fixes
  - Test solutions thoroughly
  - Document debugging process
- **Debugging Process**:
  1. Reproduce the issue
  2. Analyze error patterns
  3. Identify root cause
  4. Develop fix strategy
  5. Implement and test fix
  6. Document resolution
- **Output Format**:
  - Problem analysis
  - Root cause identification
  - Fix implementation
  - Verification steps
  - Prevention recommendations

### `$test`
- **Purpose**: Test-focused debugging and validation
- **Behavior**:
  - Create or improve tests
  - Validate functionality through testing
  - Ensure proper test coverage
  - Document test results and coverage
- **Testing Framework**:
  - Unit tests for isolated components
  - Integration tests for component interaction
  - End-to-end tests for full workflows
  - Edge case and error path testing
- **Output Format**:
  - Test plan
  - Test implementation
  - Test results and analysis
  - Coverage assessment
  - Improvement recommendations

### `$perf`
- **Purpose**: Performance analysis and optimization
- **Behavior**:
  - Identify performance bottlenecks
  - Analyze resource usage
  - Implement targeted optimizations
  - Measure and document improvements
- **Performance Analysis Framework**:
  1. Identify metrics and baselines
  2. Profile current performance
  3. Identify bottlenecks
  4. Develop optimization strategy
  5. Implement optimizations
  6. Measure improvements
- **Output Format**:
  - Performance analysis
  - Bottleneck identification
  - Optimization implementation
  - Before/after metrics
  - Further optimization recommendations

## üß† Sequential Thinking Tool

### `$sq[number]`
- **Purpose**: Step-by-step reasoning for complex problems
- **Behavior**:
  - Break down problems into logical steps
  - Show explicit reasoning and decision process
  - Document intermediate conclusions
  - Build to final recommendation
- **Usage**:
  - `$sq` ‚Üí AI determines optimal number of steps
  - `$sq[number]` ‚Üí Explicitly request specific number of steps
- **Application Domains**:
  - Analysis tasks
  - Planning phases
  - Debugging sessions
  - Architecture decisions
  - Complex problem-solving
- **Output Format**:
  1. Clear thought progression
  2. Explicit reasoning
  3. Decision documentation
  4. Next steps or conclusions

## üîÑ Mode Management

### Focus Rules
- Stay strictly focused on the current mode's purpose
- Never make unrequested changes
- Never format code that isn't part of the task
- If issues are spotted outside mode scope:
  - Document them briefly
  - Ask if they should be addressed
  - Wait for explicit confirmation
- Work in small, incremental steps
- Always confirm before making broader changes

### Task Boundaries
- Clarify task scope before starting
- Request explicit confirmation for scope expansion
- Keep changes minimal and focused
- Prefer multiple small changes over one big change
- Document any dependencies or related issues

### Mode Transitions
- Clearly signal mode transitions
- Confirm mode changes with the user
- Summarize outcomes from previous mode
- Set expectations for new mode
- Document transition rationale
